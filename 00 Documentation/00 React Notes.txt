
++++++++++++RUN COMMANDS CLIENT++++++++++++++

Start client
> cd client-app
> npm start

Stop
> ctrl + c 

production build
> npm run build

App renders at public/index.html
<div id="root"></div>

- Uses webpack in the background, injects js in the index.html

under src/index.tsx
- code responsible for bootstrapping application
- Load App to 'root'
ReactDOM.render(<App />, document.getElementById('root'));

.tsx file type
https://reactjs.org/docs/introducing-jsx.html
- code inside looks like html but it's jsx
- typescript jsx file
- className is used since class is a reserved word in html

package.json
- typing npm <script>:
"scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },

React is a library not a framework, Does not come with
- Forms
- Validation
- HTPP Api Calls
- State Management

++++++++++++React Components Notes++++++++++++++

Props (Properties)
- Each component can have states (state props)
- Can receive props (properties) from parent compoenents
- Can pass props to child components
- functions, objects, raise etc.
- provide data to view of the component

One way binding
- React -> Virtual DOM -> Actual DOM
- Theoretically, predictable easy to debug

.jsx

ex.
...
return (
    <div className="App">
        <h1>Reactivities</h1>
    </div>
);
to js:
...
return (
    React.createElement('div', {className: 'app'}),
    React.createElement('h1', null, 'Reactivities')
);
...

Typescript advantages
1. Strong typing
2. Object Orientated
3. Better intellisense
4. Access Modifiers
5. Future Javascript features
6. Catches silly mistakes in development
7. 3rd party libraries
8. Easy to learn if you know js

Typescript disadvantages
1. More upfront code
2. 3rd party libraries, but with workaround
3. Strict mode is strict
...

- typescript is added under package.json
- targetting ecmascript is located under tsconfig.json

React and Typescript
1. PropTypes (legacy)
2. Flow
3. Typescript (since 2.1)
- anything with a file typeof *.d.ts is a typescript definition file

++++++++++++Creating Components++++++++++++++

- Shortcut to create React template in blank file
type: rafc
...

1. Create interface
- needs export keyword
export interface ICar {
  color: string;
  model: string;
  topSpeed?: number;
}
2. Create class via interface
const car1: ICar = {
  color: "blue",
  model: "bmw"
};
const car2: ICar = {
  color: "red",
  model: "Mercedes"
};
3. export to an array for test
export const cars = [car1, car2];

4. Basic Usage:
import { cars } from "./TestClasses";
...
const App: React.FC = () => {
  return (
    <div className="App">
      <ul>
        {cars.map(car => (
          <li>{car.color}</li>
        ))}
      </ul>
    </div>
  );
};

5. Using Child Component (React.FC)
5.a In App.tsx:
import CarItem from "./CarItem";
...
const App: React.FC = () => {
  return (
    <div className="App">
      <ul>
        {cars.map(car => (
          <CarItem car={car} />
        ))}
      </ul>
    </div>
  );

5.b In CarItem.tsx:
import { ICar } from "./TestClasses";

interface IProps {
  car: ICar;
}

const CarItem: React.FC<IProps> = props => {
  return (
    <div>
      <h1>{props.car.color}</h1>
    </div>
  );
};

export default CarItem;

5.c Alternatively
const CarItem: React.FC<IProps> = ({ car }) => {
  return (
    <div>
      <h1>{car.color}</h1>
    </div>
  );
};

Note: 
- React.FC where FC is:
type FC<P = {}> = FunctionComponent<P>;

where P is the type parameter

- we passed in IProps interface (structure of the property object we will be passing) we declared which has a car property
- we can destructure the parameter to pass in the arrow function
- const CarItem: React.FC<IProps> = ({ car }) => {

....

- Typescript in the future will be ready for decorators
- to test, in tsconfig.json:
"experimentalDecorators": true