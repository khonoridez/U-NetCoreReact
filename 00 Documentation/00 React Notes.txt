
++++++++++++RUN COMMANDS CLIENT++++++++++++++

Start client
> cd client-app
> npm start

Stop
> ctrl + c 

production build
> npm run build

App renders at public/index.html
<div id="root"></div>

- Uses webpack in the background, injects js in the index.html

under src/index.tsx
- code responsible for bootstrapping application
- Load App to 'root'
ReactDOM.render(<App />, document.getElementById('root'));

.tsx file type
https://reactjs.org/docs/introducing-jsx.html
- code inside looks like html but it's jsx
- typescript jsx file
- className is used since class is a reserved word in html

package.json
- typing npm <script>:
"scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },

React is a library not a framework, Does not come with
- Forms
- Validation
- HTPP Api Calls
- State Management

++++++++++++Hooks++++++++++++++

- React is pushing for Hooks rather than Components, in managing State and Life Cycle components

1. Its hard to reuse stateful logic between components
2. Complex components become hard to understand
3. Classes confuse both people and machine
4. Hooks let you use React features without classes

++++++++++++React Components Notes++++++++++++++

Props (Properties)
- Each component can have states (state props)
- Can receive props (properties) from parent compoenents
- Can pass props to child components
- functions, objects, raise etc.
- provide data to view of the component

One way binding
- React -> Virtual DOM -> Actual DOM
- Theoretically, predictable easy to debug

.jsx

ex.
...
return (
    <div className="App">
        <h1>Reactivities</h1>
    </div>
);
to js:
...
return (
    React.createElement('div', {className: 'app'}),
    React.createElement('h1', null, 'Reactivities')
);
...

Typescript advantages
1. Strong typing
2. Object Orientated
3. Better intellisense
4. Access Modifiers
5. Future Javascript features
6. Catches silly mistakes in development
7. 3rd party libraries
8. Easy to learn if you know js

Typescript disadvantages
1. More upfront code
2. 3rd party libraries, but with workaround
3. Strict mode is strict
...

- typescript is added under package.json
- targetting ecmascript is located under tsconfig.json

React and Typescript
1. PropTypes (legacy)
2. Flow
3. Typescript (since 2.1)
- anything with a file typeof *.d.ts is a typescript definition file

++++++++++++Creating Components++++++++++++++

- Shortcut to create React template in blank file
type: rafc
...

1. Create interface
- needs export keyword
export interface ICar {
  color: string;
  model: string;
  topSpeed?: number;
}
2. Create class via interface
const car1: ICar = {
  color: "blue",
  model: "bmw"
};
const car2: ICar = {
  color: "red",
  model: "Mercedes"
};
3. export to an array for test
export const cars = [car1, car2];

4. Basic Usage:
import { cars } from "./TestClasses";
...
const App: React.FC = () => {
  return (
    <div className="App">
      <ul>
        {cars.map(car => (
          <li>{car.color}</li>
        ))}
      </ul>
    </div>
  );
};

++++++++++++Child Components++++++++++++++

5. Using Child Component (React.FC)
5.a In App.tsx:
import CarItem from "./CarItem";
...
const App: React.FC = () => {
  return (
    <div className="App">
      <ul>
        {cars.map(car => (
          <CarItem car={car} />
        ))}
      </ul>
    </div>
  );

5.b In CarItem.tsx:
import { ICar } from "./TestClasses";

interface IProps {
  car: ICar;
}

const CarItem: React.FC<IProps> = props => {
  return (
    <div>
      <h1>{props.car.color}</h1>
    </div>
  );
};

export default CarItem;

5.c Alternatively
const CarItem: React.FC<IProps> = ({ car }) => {
  return (
    <div>
      <h1>{car.color}</h1>
    </div>
  );
};

Note: 
- React.FC where FC is:
type FC<P = {}> = FunctionComponent<P>;

where P is the type parameter

- we passed in IProps interface (structure of the property object we will be passing) we declared which has a car property
- we can destructure the parameter to pass in the arrow function
- const CarItem: React.FC<IProps> = ({ car }) => {

....

- Typescript in the future will be ready for decorators
- to test, in tsconfig.json:
"experimentalDecorators": true

++++++++++++React Tools++++++++++++++

1. React DevTools as Chrome Extension
- on f12 Developer Tools, Tabs "Components", "Profiler"

++++++++++++Component++++++++++++++
- to use the Api in a traditional way we will use Components instead of FunctionComponent

1. do a named import for Component
import ...{ Component } from "react";

2. replace App declaration
from:
const App: React.FC = () => {
to:
class App extends Component {
  render() {
    return <div className="App"></div>;
  }
}

3. Component has required function render()...
4. We now have access to lifecycles, but not states
- componentDidCatch
- componentDidMount

+++++++++History+++++++++
React 0.3
May 2013

- class did not exist yet in Javascript
- To receive props and set states React has .createClass

React 0.13.0
Jan 2015

- Release of ES6
- Class declarations inside Javascript
- React use Javascript classes instead
- We do this by extending from React.Component
- invoke, and also pass the props: super(props)
- we would have to bind them inside the constructor
constructor(props){
	...
	this.delta.bind(this);
}
- However there are cases when this does not bind properly, should be:
this.delta = this.delta.bind(this);

- Class fields proposals , allows to declare state as class property, without needing a constructor, arrow functions were used to bind. 
However he keyword this still exist. to make React easier to learn, Hooks were developed