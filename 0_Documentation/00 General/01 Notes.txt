
++++++++++++RUN COMMANDS++++++++++++++

Start client
> cd client-app
> npm start

RUN API, VS Code
- Under Terminal, using dotnet cli
- Only works inside the context of the startup project, error in solution level even with -p switch
> cd API
> dotnet watch run

- Specify startup project
- Run:
> dotnet run -p API/

Recommend dotnet cli in creating Projects

Check versions:
> dotnet --info

Help for dotnet cli
> dotnet -h
> dotnet new -h
> dotnet new <shortname>

...

Install packages (must be same as netcore version)
- open command shell (ctrl+shift+p)
- Nuget Package Manager: Add Package
- Add to Project
- Restore pop-up window

++++++++++++EF Codes ADD MIGRATION++++++++++++++
!!!IN SOLUTION LEVEL
!specify -p is the persistence project
!specify -s is the startup project
> dotnet ef migrations add InitialCreate -p Persistence/ -s API/

!updates to the latest migration if no migration is specified
> dotnet ef database update <migration>

!create new migration for seed
-p for datacontext project
-s startup project
> dotnet ef migrations add SeedValues -p Persistence/ -s API/

++++++++++++RESETTING DATABASE++++++++++++++
1. Inside VS Code Terminal Window, inside solution folder

2. Drop database
- Specify persistence project and startup project

dotnet ef database drop -p Persistence/ -s API/

3. Re run Api since we have migration setup in startup
dotnet watch run

++++++++++++POSTMAN FEATURES++++++++++++++
1. Variables
- under collections > edit
- rightmost tab "Parameters"
- set value for parameter "url"
- usage: {{url}}/api/activities

2. Creating Collections
https://learning.getpostman.com/docs/postman/collections/intro_to_collections/

3. Postman Tests
https://learning.getpostman.com/docs/postman/scripts/test_examples/

3.1. ex. Module 14 Login as bob and save token to env
- Under test tab
const user = pm.response.json();

pm.test("Has properties", function () {
    pm.expect(user).to.have.property('displayName');
    pm.expect(user).to.have.property('username');
    pm.expect(user).to.have.property('image');
    pm.expect(user).to.have.property('token');
});

if (pm.test("Has properties")) {
    pm.globals.set('token', user.token);
}

pm.test("Global token has been set", function() {
    var token = pm.globals.get('token');
    pm.expect(token).to.eql(user.token);
});

- This would set a global variable in Postman if it does not exist

3.2. Under the settings button upper right (Environment), Globals button
- we can access the global variables that were set

3.3. sending the request will trigger the script

3.4 Usage: 
Get Activities
{{url}}/api/activities
- in Headers tab we have value for the Authorization key as: 
Bearer {{token}}

4. Dynamic variables
- Used in create Activity
https://learning.getpostman.com/docs/postman/environments_and_globals/variables/#dynamic-variables
{{$guid}} : Adds a v4 style guid
https://stackoverflow.com/questions/37851383/what-is-guid-used-for-in-postman

++++++++++++DEBUGGING IN VS CODE++++++++++++++
1. Verify in .vscode/launch.json
{
    "name": ".NET Core Attach",
    "type": "coreclr",
    "request": "attach",
    "processId": "${command:pickProcess}"
}

2. In Debug Tab, select .Net Core Attach in dropdown
- .Net Core Launch will start a new instance

3. Debug. Search for Api.dll, api.exe

4. Note on [ApiController] attribute
- This throws its own errors hence breakpoitn might not trigger
- comment out [ApiController] for verification

5. Verify values under Variables/Locals/


++++++++++++API SECURITY++++++++++++++

1. TokenValidationParameters
https://docs.microsoft.com/en-us/dotnet/api/microsoft.identitymodel.tokens.tokenvalidationparameters?view=azure-dotnet
- ValidateAudience - Validation of the audience, mitigates forwarding attacks. For example, a site that receives a token, could not replay it to another side.
- ValidateIssuer - Gets or sets a String that represents a valid issuer that will be used to check against the token's issuer.

2. Policy-based authorization
- Used in /Infrastructure/Security/IsHostRequirement.cs
https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-3.0

++++++++++++++User Secrets++++++++++++++
1. In the Api.csproj file add User Secrets id
- ex. copy existing Guid from an Activity id
<PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
	<UserSecretsId>a09d8666-de6a-45b7-82ae-69e8d8e33cd1</UserSecretsId>
</PropertyGroup>

2. In VS Code terminal, Solution level
-p : specify startup project
dotnet user-secrets set "TokenKey" "super secret key" -p API/

++++++++++++AutoMapper++++++++++++++
https://automapper.org/
- same author as MediatR
- AutoMapper.Extensions.Microsoft.DependencyInjection 7.0.0

ex. CreateMap<Activity, ActivityDto>();
- Convention based, 
- any properties that has the same name, will automatically be mapped
- no code needed

++++++++++++Ordering of Services in ConfigureServices++++++++++++++
https://stackoverflow.com/questions/55706344/what-is-correct-order-to-addcors-into-net-core

As a general rule, the MVC middleware almost always should come last.

https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30?view=aspnetcore-3.0&tabs=visual-studio#startup-changes
For most apps, calls to UseAuthentication, UseAuthorization, and UseCors must appear between the calls to UseRouting and UseEndpoints to be effective.
