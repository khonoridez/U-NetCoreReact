
++++++++++++++Placeholder Loader++++++++++++++
- using Semantic UI Placeholder
- https://react.semantic-ui.com/elements/placeholder/
1. Create file ActivityListItemPlaceholder.tsx
client-app\src\features\activities\dashboard\ActivityListItemPlaceholder.tsx
- type snippet s_22.1.0
- structure of the Placeholder mimics a blank ActivityListItem
<Segment...

2. In ActivityDashboard.tsx
- swap LoadingComponent with ActivityListItemPlaceholder
- 
<GridColumn width="10">
{loadingInitial && page === 0 ? (
    <ActivityListItemPlaceholder />
) : (
    <InfiniteScroll
    pageStart={0}
    loadMore={handleGetNext}
    hasMore={!loadingNext && page + 1 < totalPages}
    initialLoad={false}
    >
    <ActivityList />
    </InfiniteScroll>
)}
</GridColumn>

++++++++++++++loader on index.html++++++++++++++
- there is a brief text "Reactivities" when page gets refreshed on browser
- this comes from <div id="root">Reactivities</div> in client-app\public\index.html
1. In client-app\src\app\layout\App.tsx set LoadingComponent to true, return flag back after copy
if (true) return <LoadingComponent content="Loading app..." />;

2. In browser, copy the html equivalent of the LoadingComponent redenred in <div id="root">
<div class="ui active transition visible inverted dimmer" style="display: flex !important;"><div class="content"><div class="ui text loader">Loading app...</div></div></div>

3. Paste inside the <div id="root"> in client-app\public\index.html

++++++++++++++Authentication holes++++++++++++++
- log out, then go to /activities
- user will still be redirected to correct page
- implement everywhere aside from homepage
- Implement private routes in client-app\src\app\layout\App.tsx, apply if not logged in

1. Create file client-app\src\app\layout\PrivateRoutes.tsx
1.1 Create interface IProps that extends RouteProps along with other properties
- Desctructure props in component
interface IProps extends RouteProps {
  component: React.ComponentType<RouteComponentProps<any>>;
}

const PrivateRoute: React.FC<IProps> = ({ component, ...rest }) => {
...

2. Get rootStore.userStore to check user if logged in
- destructure isLoggedIn
const rootStore = useContext(RootStoreContext);
const { isLoggedIn } = rootStore.userStore;

3. Return Route
- pass rest of the properties
- handle render depending on user is loggedin or not
return (
    <Route
      {...rest}
      render={props =>
        isLoggedIn ? <Component {...props} /> : <Redirect to={"/"} />
      }
    />
  );

4. Set observer for PrivateRoute
- Since we are checking an obserable (isLoggedIn)
export default observer(PrivateRoute);

5. Set PrivateRoute for the routes in App.tsx
...
<Switch>
    <PrivateRoute
        exact
        path="/activities"
        component={ActivityDashboard}
    />
    <PrivateRoute
        path="/activities/:id"
        component={ActivityDetails}
    />
    <PrivateRoute
        key={location.key}
        path={["/createActivity", "/manage/:id"]}
        component={ActivityForm}
    />
    <PrivateRoute
        path="/profile/:username"
        component={ProfilePage}
    />
    <Route component={NotFound} />
</Switch>
...

!! Note: There is no such thing as client-side secruity
- Hiding behind the curtains rather than a locked door
- Server data protection is a requriement
