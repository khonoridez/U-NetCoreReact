
+++++++++++++++++Outline+++++++++++++++++
1. Paging on the Api and Client
- send initial batch of results and continously send results as user browse down
2. Filtering on Api and Client
3. Sorting on Api and Client

!! Implement IQueryable<T>

+++++++++++++++++Paging+++++++++++++++++
- Note: there are several ways to implement paging

1. Implement paging under /Application/Activities/List, we need to pass in another property ActivityCount
1.1 Create new class ActivitiesEnvelope with 2 properties
public class ActivitiesEnvelope
{
    public List<ActivityDto> Activities { get; set; }
    public int ActivityCount { get; set; }
}

1.2 Replace return type of List Handler to ActivitiesEnvelope
public class Handler : IRequestHandler<Query, ActivitiesEnvelope>
...

1.3 Add optional parameters for List handler's query assign to constructor
- This will serve as properties for paging count
public class Query : IRequest<List<ActivitiesEnvelope>>
{
    public Query(int? limit, int? offset)
    {
        Limit = limit;
        Offset = offset;
    }

    public int? Limit { get; set; }
    public int? Offset { get; set; }
}

1.4 Create Queryable in Handler method
var queryable = _context.Activities.AsQueryable();

1.5 Call for activities and call skip and take based on query parameters
- Skip how many records in the table (default 0)
- Take the number of items (default 3)
var activities = await queryable
        .Skip(request.Offset ?? 0)
        .Take(request.Limit ?? 3)
        .ToListAsync();

1.6 Instantiate and return new ActivitiesEnvelope
return new ActivitiesEnvelope
{
    Activities = _mapper.Map<List<Activity>, List<ActivityDto>>(activities),
    ActivityCount = queryable.Count()
};

1.7 Adjust in Api Controller
- Replace Return type to List.ActivitiesEnvelope
- Add and pass parameters limit and offset

[HttpGet]
public async Task<ActionResult<List.ActivitiesEnvelope>> List(int? limit, int? offset)
{
    return await Mediator.Send(new List.Query(limit, offset));
}

1.8 Test in Postman
- Module 21